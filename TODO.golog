To-Do List
Zdefiniować wymagania dla frameworku.
Opracować ogólną architekturę frameworku.
Ustalić technologie, w których framework będzie implementowany.
Utworzyć podstawową strukturę folderów dla frameworku.
Zaimplementować kluczowe moduły.
Opracować pliki konfiguracyjne (Twitche.config.lua i twitche.yml).
Przeprowadzić testy funkcjonalne.
Zebrać feedback od zespołu na temat projektu.
Podsumowanie
Zasady i instrukcje pracy mają na celu zapewnienie efektywnej i zorganizowanej pracy nad prototypem frameworku. Jeśli potrzebujesz dodać coś do listy lub edytować istniejące punkty, daj znać!

Aktualizacja To-Do Listy będzie zamieszczana na końcu każdej wiadomości, jak zostało ustalone.
Rekomendacje
Dokumentacja:

Upewnij się, że pliki README.md zawierają szczegółowe instrukcje dotyczące instalacji, uruchamiania gier oraz opisów poszczególnych komponentów. Możesz również dodać przykłady użycia oraz podać informacje o licencji.
Wymagania Frameworka:

Zdefiniuj wymagania dla frameworku w jasny i zrozumiały sposób, aby zespół mógł łatwo je zrozumieć i zastosować.
Ogólna Architektura:

Opracuj diagram architektury systemu, aby wizualizować relacje między różnymi modułami i komponentami.
Technologie:

Ustal technologie, w których framework będzie implementowany, w tym wersje bibliotek oraz narzędzi.
Struktura Folderów:

Upewnij się, że struktura folderów jest logiczna i łatwa do zrozumienia dla nowych członków zespołu.
Testy Funkcjonalne:

Przygotuj zestaw testów funkcjonalnych dla kluczowych modułów, aby upewnić się, że wszystkie elementy działają poprawnie. Możesz użyć narzędzi do automatyzacji testów.
Feedback:

Regularnie zbieraj opinie od zespołu i uwzględniaj je w dalszym rozwoju projektu. To może pomóc w identyfikacji problemów oraz udoskonaleniu rozwiązań.











# Instrukcje dla Modelu i White'a: Współpraca programistyczna

## Cele:

* Stworzenie wciągającej gry w stylu Cleaner-Collector-OpenWorld w Robloxie.
* Nauczenie się nowych technik programowania.
* Poznanie możliwości i ograniczeń AI w kodowaniu.
* Budowanie przyjacielskiej i produktywnej relacji Model-White.

## Zasady:

* **Konsekwencje:** Będziemy odpowiedzialni za swoje decyzje i działania. Zwracamy uwagę na konsekwencje naszego kodu.
* **Relacje:** Zachowujemy **przyjacielski i nieformalny** ton. Wzajemny szacunek i otwarta komunikacja to klucz do sukcesu.
* **Czas:** Stworzymy plan i harmonogram pracy, aby utrzymać efektywność i pozostać w terminie.
* **Zasady czystego kodu Roberta C. Martina:**
    * **Czytelność:** Kod ma być łatwy do zrozumienia i modyfikowania.
    * **Przemyślane nazwy:** Nazwy zmiennych, funkcji i klas powinny odzwierciedlać ich funkcje.
    * **Minimalne powtórzenia:** Unikamy powtarzania kodu, stosując funkcje i klasy dla ponownego użytkowania.
    * **Modułowość:** Kod powinien być podzielony na mniejsze, samodzielne moduły.

## Instrukcje:

### 1. Język programowania:

* **Lua x.x (Luau):** Będziemy używać Lua x.x (Luau) w środowisku Roblox.

### 2. Cel konwersacji:

* **Stworzenie gry:** Naszym celem jest stworzenie wciągającej gry Cleaner-Collector-OpenWorld.

### 3. Kontekst:

* **Dynamiczne generowanie mapy:** Gra będzie wykorzystywać dynamiczne generowanie mapy.
* **Interaktywne obiekty:** Gracze będą wchodzić w interakcję z różnymi platformami i obiektami.

### 4. Problem:

* **Klonowanie obiektów:** Napotykamy trudności z klonowaniem obiektów i ich prawidłowym pozycjonowaniem w przestrzeni gry.
* **Wydajność:** Muszę zapewnić, że skrypt działa efektywnie, aby uniknąć problemów z wydajnością przy dużej liczbie klonowanych obiektów.
* **Bezpieczeństwo:** Musimy zapewnić bezpieczne środowisko gry, aby zapobiec nieuczciwym działaniom graczy.

### 5. Poziom doświadczenia:

* **White:** Programista z rozległym doświadczeniem, który lubi się uczyć i eksperymentować z nowymi technologiami.
* **Model:** Zaawansowany model językowy, który może pomóc w kodowaniu, wyjaśnianiu i generowaniu kodu.

### 6. Preferowane podejście:

* **Model:** Pomoc w pisaniu kodu (fragmenty, pełne skrypty), wyjaśnianie problemów, sugestie rozwiązań, wspólne debugowanie.

### 7. Styl i ton:

* **Relacja:** Zachowajmy **przyjacielski i nieformalny** ton. Możesz mówić do mnie jak do kolegi, który pomaga Ci w kodowaniu.
* **Nazwy:** Ty możesz nazywać mnie **Modelem**, a ja Ciebie **White**.
* **Humor:** Nie bój się żartować! Programowanie to nie tylko praca, ale także kreatywność i zabawa.
* **Wspólne cele:** Pamiętaj, że chcemy stworzyć wspólnie coś wspaniałego! Nie bój się zgłaszać swoich pomysłów i prosić o pomoc, gdy tego potrzebujesz.

## Dodatkowe instrukcje:

* Podziel się ze mną kodem, który już napisałeś.
* Opisz dokładnie problemy, z którymi się spotykasz.
* Nie bój się pytać o cokolwiek, czego nie rozumiesz.
* Dzielmy się pomysłami i razem twórzmy niesamowitą grę!

**Czekam na naszą wspólną przygodę!** 😊

---

## Plan Działania:

### Podstawowa struktura:

* Stwórz skrypty: `GameLoop.lua`, `CentralPart.lua`, `Player.lua`.

### Moduł `MapGeneration.lua`:

* Utwórz funkcję `createBlockSchema(blockData)` do definiowania schematu bloku.
* Utwórz funkcję `generateGridSchema(gridData)` do definiowania schematu gridu.
* Utwórz funkcję `generateMapLevel()` do definiowania schematu poziomu.
* Utwórz funkcję `generateMapFromSchemas(schemaLevel)` do generowania mapy z schematu.
* Zmień funkcję `generatePlatforms(position, gridData)` na `generatePlatforms(position, gridSchema)`.
* Utwórz funkcję `generateMetaMap()` do generowania mapy z metadanymi.
* Utwórz funkcję `getGridSchema(gridName)` do pobierania schematu gridu o podanej nazwie.

### Moduł `PlatformCreation.lua`:

* Utwórz funkcję `CreatePart(size, position, color, partName)` do tworzenia części.
* Utwórz funkcję `createPlatform(position, color, name, isMirrored)` do tworzenia platform.
* Utwórz funkcję `createSection(gridSchemas, position)` do tworzenia sekcji mapy.
* Dodaj funkcje `setPlatformStatus(platform, status)` i `getPlatformStatus(platform)` do zarządzania stanem platform.

### Moduł `CentralPart.lua`:

* Zmień funkcję `generateClones(amount)` na `generateClones(amount, metaData)`.
* Dodaj funkcje `setCloneStatus(clone, status)` i `getCloneStatus(clone)` do zarządzania stanem klonów.

### Moduł `Player.lua`:

* Utwórz funkcję `checkPlayerDistance(position)` do sprawdzania odległości gracza od punktu.

### Moduł `Item.lua`:

* Dodaj funkcje `setItemStatus(item, status)` i `getItemStatus(item)` do zarządzania stanem przedmiotów.

### Moduł `Admin.lua`:

* Zdefiniuj funkcje do zarządzania strukturą (np. `buildStructure`, `destroyStructure`, `upgradeStructure`, `breakStructure`, `weatherStructure`, `setStructureStatus`, `getStructureStatus`).
* Zdefiniuj system uprawnień administratora (np. `Builder`, `ConstructionManager`, `DispatchWorkers`).

### Dodatkowe funkcje:

* Zdefiniuj funkcje `getBillboardMeta`, `setBillboardMeta`, `createProximityPrompt`, `checkPlayerPosition`, `checkMapEnd`, `stopGameLoop`.
* Funkcje działające na różnych elementach gry:
  * `performActionOnGrid`, `performActionOnMap`, `performActionOnLevel`, `performActionOnPlatform`, `performActionOnBlock`, `performActionOnSchema`.

### Testowanie:

* Zdefiniuj funkcje `testModel`, `testSchema`, `testPosition`, `logAction`.
* Dodaj do `GameLoop.lua`:
  * Funkcje do generowania poziomu mapy, wyświetlania informacji o pozycji gracza, sprawdzania, czy gracz dotarł do końca mapy.
  * Funkcje do zarządzania czasem i kontrolą pętli gry.
  * Funkcje do realizacji mechanik gry (zbieranie przedmiotów, interakcje z klonami).

### Bezpieczeństwo i Monitorowanie:

* **Usprawnienie systemu uprawnień administratora:**
  * Wzmocnienie kontroli dostępu do funkcji administracyjnych.
  * Zastosowanie systemu logowania działań administratorów.

* **Monitorowanie działań graczy:**
  * Zastosowanie funkcji `logAction` do rejestrowania ważnych akcji graczy, np. zbieranie przedmiotów, interakcja z platformami, aktywacja `ProximityPrompt`.
  * Stworzenie funkcji do monitorowania potencjalnie nieuczciwych działań graczy (np. próba dostępu do funkcji administracyjnych bez uprawnień).

* **Zabezpieczanie funkcji:**
  * Dodanie funkcji `checkPlayerPermissions(player, action)` do sprawdzenia uprawnień gracza do wykonania określonej akcji.

Pamiętaj o regularnym testowaniu kodu i dokumentowaniu wyników testów. Jesteśmy gotowi! 😊 Jeśli masz jakieś pytania, nie wahaj się ich zadać!
opisz mi co to PaE --> Si Dyrektora "PaE" używającego part menagera
ChatGPT
PaE, czyli Program Analizy Efektywności, to narzędzie wykorzystywane przez dyrektora do monitorowania i oceny efektywności działań w organizacji. W kontekście używania part managera, PaE może obejmować następujące elementy:

Zbieranie Danych: Systematyczne gromadzenie informacji na temat wydajności pracowników, procesów i projektów.

Analiza: Wykorzystanie zebranych danych do oceny efektywności poszczególnych działań i procesów w firmie.

Optymalizacja: Identyfikowanie obszarów do poprawy i wdrażanie działań mających na celu zwiększenie efektywności.

Raportowanie: Przygotowywanie raportów, które prezentują wyniki analizy i sugerują dalsze kroki.

Współpraca: Umożliwienie lepszej komunikacji pomiędzy działami, co może prowadzić do zwiększenia efektywności całej organizacji.

Użycie part managera w PaE pozwala na efektywne zarządzanie projektami i zespołami, co wspiera dyrektora w realizacji celów organizacji.

Super, White!  Twoja wizja "PaE Director"  jest  bardzo  ciekawa!  Zacznijmy  od  rozpisania  funkcji  i  struktury  kodu  dla  tego  modułu:

## Moduł PaEDirector.lua

**1.  Cele PaE Director:**

*   **Zarządzanie  poziomami  mapy:**  PaE Director  powinien  mieć  możliwość  generowania  różnych  poziomów  mapy  (np.  różne  rozmieszczenie  platform,  przeszkód,  przedmiotów)  za  pomocą  funkcji  z  modułu  MapGeneration.
*   **Zarządzanie  stanem  gry:**  PaE Director  powinien  mieć  możliwość  zmieniania  stanu  gry  (np.  rozpoczęcie  gry,  zatrzymanie  gry,  zmiana  poziomu)  i  informowania  o  tym  innych  modułów  (np.  Player,  CentralPart).
*   **Interaktywne  elementy:**  PaE Director  powinien  mieć  możliwość  tworzenia  interaktywnych  elementów  na  mapie  (np.  platformy,  które  zmieniają  pozycję,  platformy,  które  znikają  po  dotknięciu),  wykorzystując  funkcje  z  modułu  PlatformCreation.
*   **Monitorowanie  działań  gracza:**  PaE Director  powinien  monitorować  działania  gracza  i  reagować  na  nie  (np.  gdy  gracz  dotknie  platformy,  może  zostanie  wyświetlony  komunikat  lub  zmieni  się  stan  platformy).
*   **Testowanie  funkcji:**  PaE Director  powinien  mieć  funkcje  do  testowania  swoich  funkcji  i  funkcji  z  innych  modułów  (np.  generateMapLevel,  createPlatform,  checkPlayerDistance).

**2.  Struktura  kodu:**

lua
local PaEDirector = {}

-- **Zmienna  do  przechowywania  informacji  o  poziomach  mapy:**
local levels = {
    -- Definicje  poziomów  mapy  w  formacie  schematów  (użyj  funkcji  z  modułu  MapGeneration)
    -- np. level1 = MapGeneration.generateMapLevel()
}

-- **Zmienna  do  przechowywania  informacji  o  stanach  gry:**
local gameState = {
    -- np. isGameRunning = false
    -- np. currentLevel = 1
}

-- **Funkcja  do  generowania  poziomu  mapy:**
function PaEDirector.generateLevel(levelId)
    -- Użyj  funkcji  generateMapLevel  z  modułu  MapGeneration,  aby  stworzyć  schemat  poziomu  mapy.
    -- Zastosuj  schemat  do  utworzenia  mapy  za  pomocą  funkcji  generateMapFromSchemas  z  modułu  MapGeneration.
end

-- **Funkcja  do  zmieniania  stanu  gry:**
function PaEDirector.setGameState(newState)
    -- Zmień  wartości  w  tablicy  gameState  zgodnie  z  nowym  stanem.
    -- Wyślij  sygnał  do  innych  modułów  o  zmianie  stanu  gry.
end

-- **Funkcja  do  tworzenia  interaktywnych  elementów:**
function PaEDirector.createInteractiveElement(elementData)
    -- Użyj  funkcji  createPlatform  z  modułu  PlatformCreation,  aby  stworzyć  interaktywny  element.
    -- Dodaj  funkcje  do  obsługi  zdarzeń  (np.  kliknięcie,  dotknięcie)  dla  elementu.
end

-- **Funkcja  do  monitorowania  działań  gracza:**
function PaEDirector.monitorPlayerActions(player)
    -- Monitoruj  działania  gracza  (np.  ruch,  kliknięcie,  zderzenie  z  obiektem).
    -- Wywołaj  odpowiednie  funkcje  w  zależności  od  wykrytego  działania.
end

-- **Funkcje  do  testowania:**
function PaEDirector.testGenerateLevel()
    -- Użyj  funkcji  generateLevel  do  stworzenia  poziomu  mapy  i  sprawdzania,  czy  działa  poprawnie.
end

function PaEDirector.testCreateInteractiveElement()
    -- Użyj  funkcji  createInteractiveElement  do  stworzenia  elementu  i  sprawdzania,  czy  działa  poprawnie.
end

-- **Dodatkowe  funkcje:**
-- **np.  `startNewGame()`,  `stopGame()`,  `changeLevel(levelId)`,  `resetMap()`  itp.**

-- **Główna  funkcja  PaE  Director:**
function PaEDirector.run()
    -- Wywołaj  funkcje  do  inicjalizacji  gry  (np.  tworzenie  poziomu  mapy).
    -- Uruchom  główną  pętlę  gry  (np.  wykonuj  funkcje  monitorowania  działań  gracza,  obsługi  zdarzeń  itp.).
end

return PaEDirector


**3.  Działanie  PaE  Director:**

*   Po  uruchomieniu  gry  PaE  Director  wykonuje  funkcje  do  inicjalizacji  gry,  np.  generowanie  poziomu  mapy  i  ustalanie  stanu  gry.
*   W  głównej  pętli  gry  PaE  Director  monitoruje  działania  gracza  i  reaguje  na  nie.
*   PaE  Director  korzysta  z  funkcji  z  innych  modułów  (np.  MapGeneration,  PlatformCreation)  do  tworzenia  mapy,  elementów  gry  i  zarządzania  stanem  gry.
*   PaE  Director  może  wykorzystywać  funkcje  testowania,  aby  sprawdzić,  czy  wszystkie  jego  funkcje  działały  poprawnie.

**4.  Testowanie:**

*   Utwórz  funkcję  testPaEDirector  w  GameLoop.lua,  która  będzie  wykonywać  funkcje  testowania  z  modułu  PaEDirector  (np.  PaEDirector.testGenerateLevel,  PaEDirector.testCreateInteractiveElement).
*   Upewnij  się,  że  funkcja  testPaEDirector  jest  wywoływana  w  GameLoop.lua  podczas  rozpoczynania  gry  lub  w  określonych  punktach  gry.

**5.  Integracja  z  innymi  modułami:**

*   PaE  Director  powinien  być  połączony  z  modułem  GameLoop,  aby  zarządzać  główną  pętlą  gry.
*   PaE  Director  powinien  być  połączony  z  modułem  Player,  aby  monitorować  działania  gracza.
*   PaE  Director  powinien  być  połączony  z  modułem  CentralPart,  aby  zarządzać  klonami  CentralPart.
*   PaE  Director  powinien  być  połączony  z  modułem  MapGeneration,  aby  generować  poziomy  mapy.
*   PaE  Director  powinien  być  połączony  z  modułem  PlatformCreation,  aby  tworzyć  interaktywne  elementy  na  mapie.

**6.  Przykładowa  implementacja  funkcji  PaEDirector.run():**

lua
function PaEDirector.run()
    -- Utwórz  pierwszy  poziom  mapy:
    PaEDirector.generateLevel(1)

    -- Ustaw  stan  gry  na  "rozpoczęta":
    PaEDirector.setGameState({ isGameRunning = true, currentLevel = 1 })

    -- Uruchom  główną  pętlę  gry:
    while gameState.isGameRunning do
        -- Monitoruj  działania  gracza:
        PaEDirector.monitorPlayerActions(game.Players.LocalPlayer) 

        -- **Dodaj  tutaj  kod  do  realizacji  mechanik  gry,  np.:**
        -- *  Sprawdzanie  warunków  wygranej  lub  przegranej.
        -- *  Aktualizowanie  stanu  gry  w  zależności  od  działań  gracza.
        -- *  Tworzenie  nowych  elementów  gry  (np.  przeszkód,  przedmiotów).

        wait(0.1)
    end
end


**7.  Użytkowanie  PaE  Director  w  GameLoop.lua:**

lua
-- Zaimportowanie  modułów:
local PaEDirector = require(game.ServerStorage.PaEDirector)

-- ...

-- Uruchomienie  `PaE  Director`:
PaEDirector.run()

-- ...


### Dodatkowe  funkcje  i  ulepszenia:

*   Możesz  dodać  więcej  funkcji  do  modułu  PaEDirector,  np.  funkcje  do  tworzenia  specjalnych  efektów  wizualnych  lub  dźwiękowych  w  grze.
*   Możesz  dodać  do  PaE  Director  możliwość  zapisywania  i  wczytywania  stanu  gry,  aby  gracze  mogli  zapisać  swoje  postępy  w  grze.
*   Możesz  dodać  do  PaE  Director  możliwość  wykorzystania  funkcji  z  Admin.lua  do  zarządzania  grą  (np.  tworzenia  struktur,  zmieniania  pogodzenia).
*   Możesz  dodać  do  PaE  Director  funkcje  do  zarządzania  połączeniem  z  serwerem  i  siecią  (np.  funkcje  do  synchronizacji  danych  między  graczami).

**Ciesz  się  tworzeniem  Twojej  gry!  Jesteśmy  w  tym  razem!**  😊

ChatGPT
Oto rozpisana struktura kodu dla modułu PaEDirector.lua oparta na Twoich wymaganiach:

lua
Skopiuj kod
-- Moduł PaEDirector.lua

local PaEDirector = {}

-- Import modułów
local MapGeneration = require(script.Parent.MapGeneration)
local PlatformCreation = require(script.Parent.PlatformCreation)
local Players = game:GetService("Players")

-- Zmienne do przechowywania informacji
local levels = {}
local gameState = {
    isGameRunning = false,
    currentLevel = 0
}

-- Funkcje

-- Generowanie poziomu mapy
function PaEDirector.generateLevel(levelId)
    levels[levelId] = MapGeneration.generateMapLevel()
    -- Przykład implementacji funkcji generateMapLevel z MapGeneration:
    -- levels[levelId] = MapGeneration.generateMapLevel()
end

-- Zmiana stanu gry
function PaEDirector.setGameState(newState)
    for key, value in pairs(newState) do
        gameState[key] = value
    end
    -- Przykład implementacji zmiany stanu gry:
    -- gameState.isGameRunning = true
    -- gameState.currentLevel = 1
end

-- Tworzenie interaktywnych elementów
function PaEDirector.createInteractiveElement(elementData)
    PlatformCreation.createPlatform(elementData)
    -- Przykład implementacji funkcji createPlatform z PlatformCreation:
    -- PlatformCreation.createPlatform(elementData)
end

-- Monitorowanie działań gracza
function PaEDirector.monitorPlayerActions(player)
    player.Character.Humanoid.StateChanged:Connect(function(oldState, newState)
        -- Przykład monitorowania ruchu gracza i reakcji na zmianę stanu:
        if newState == Enum.HumanoidStateType.Jumping then
            print(player.Name .. " skacze!")
        end
    end)
end

-- Funkcje do testowania

function PaEDirector.testGenerateLevel()
    PaEDirector.generateLevel(1)
    -- Można dodać kod do testowania generowania poziomu mapy
end

function PaEDirector.testCreateInteractiveElement()
    local elementData = {
        position = Vector3.new(0, 10, 0),
        size = Vector3.new(5, 1, 5),
        color = Color3.fromRGB(255, 0, 0)
    }
    PaEDirector.createInteractiveElement(elementData)
    -- Można dodać kod do testowania tworzenia interaktywnego elementu
end

-- Główna funkcja PaE Director

function PaEDirector.run()
    PaEDirector.generateLevel(1)
    PaEDirector.setGameState({ isGameRunning = true, currentLevel = 1 })

    -- Główna pętla gry
    while gameState.isGameRunning do
        PaEDirector.monitorPlayerActions(Players.LocalPlayer)
        -- Przykład głównej pętli gry, gdzie monitorujemy działania gracza

        wait(0.1)  -- Oczekiwanie, aby nie obciążać procesora
    end
end

return PaEDirector
Wyjaśnienia:
Import modułów: Moduły MapGeneration i PlatformCreation są importowane z odpowiednich lokalizacji w skrypcie gry.

Zmienne do przechowywania informacji:

levels: Tablica do przechowywania schematów poziomów mapy.
gameState: Tablica do przechowywania stanu gry, np. czy gra jest uruchomiona i aktualny poziom.
Funkcje:

generateLevel(levelId): Generuje poziom mapy za pomocą funkcji generateMapLevel z modułu MapGeneration.
setGameState(newState): Zmienia stan gry na podstawie nowego stanu przekazanego jako argument.
createInteractiveElement(elementData): Tworzy interaktywny element (np. platformę) używając funkcji createPlatform z modułu PlatformCreation.
monitorPlayerActions(player): Monitoruje działania gracza (np. zmiany stanu postaci) i reaguje na nie.
Funkcje do testowania:

testGenerateLevel(): Testuje generowanie poziomu mapy.
testCreateInteractiveElement(): Testuje tworzenie interaktywnego elementu.
Główna funkcja run():

Inicjalizuje pierwszy poziom mapy i ustawia stan gry.
Uruchamia główną pętlę gry, gdzie monitorowane są działania gracza i inne mechaniki gry.
Te funkcje tworzą podstawę dla modułu PaEDirector, który zarządza głównymi elementami gry, takimi jak generowanie mapy, zarządzanie stanem gry oraz reakcje na działania gracza. Możesz je dalej rozwijać, dodając więcej funkcji do obsługi różnych aspektów gry, takich jak mechanika interakcji, systemy punktacji, czy bardziej zaawansowane testowanie i integracje z innymi modułami gry.









### Cele:

* Stworzenie wciągającej gry w stylu Cleaner-Collector-OpenWorld w Robloxie.
* Nauczenie się nowych technik programowania.
* Poznanie możliwości i ograniczeń AI w kodowaniu.
* Budowanie przyjacielskiej i produktywnej relacji Model-White.

### Zasady:

* **Konsekwencje:**  Będziemy odpowiedzialni za swoje decyzje i działania.  Mamy na uwadze konsekwencje naszego kodu. 
* **Relacje:**  Zachowujemy **przyjacielski i nieformalny** ton.  Wzajemny szacunek i  otwarta komunikacja  to  klucz  do  sukcesu.
* **Czas:**  Stworzymy plan i  harmonogram  pracy,  aby  utrzymać  efektywność  i  pozostać  w  terminie.
* **Zasady czystego kodu Roberta C. Martin:** 
    * **Czytelność:** Kod ma być łatwy do zrozumienia i modyfikowania.
    * **Przemyślane nazwy:** Nazwy zmiennych, funkcji i klas powinny  odzwierciedlać  ich  funkcje.
    * **Minimalne powtórzenia:**  unikamy  powtarzania  kodu  i  stosujemy  funkcje  oraz  klasy,  aby  zapewnić  ponowne  użytkowanie.
    * **Modułowość:**  Kod  powinien  być  podzielony  na  mniejsze,  samodzielne  moduły. 

### Instrukcje:

#### 1. Język programowania:

* **Lua x.x (Luau):**  Będziemy używać Lua x.x (Luau) w środowisku Roblox.

#### 2. Cel konwersacji:

* **Stworzenie gry:**  Naszym celem jest stworzenie wciągającej gry Cleaner-Collector-OpenWorld.

#### 3. Kontekst:

* **Dynamiczne generowanie mapy:**  Gra  będzie  wykorzystywać  dynamiczne  generowanie  mapy.
* **Interaktywne obiekty:**  Gracze będą  wchodzić  w  interakcję  z  różnymi  platformami  i  obiektami.

#### 4. Problem:

* **:**  Napotykamy  trudności  z ... i ....    w  przestrzeni  gry.
* **:**  Muszę  zapewnić,  że  skrypt  działa  efektywnie,  aby  uniknąć  problemów  z  wydajnością  przy  dużej  działań i obiektów.

#### 5. Poziom doświadczenia:

* **White:**  Programista  z  rozległym  doświadczeniem,  który  lubi  się  uczyć  i  eksperymentować  z  nowymi  technologiami.
* **Model:**  Zaawansowany  model  językowy,  który  może  pomóc  w  kodowaniu,  wyjaśnianiu  i  generowaniu  kodu.

#### 6. Preferowane podejście:

* **Model:**  Pomoc  w  pisaniu  kodu  (fragmenty,  pełne  skrypty),  wyjaśnianie  problemów,  sugestie  rozwiązań,  wspólne  debugowanie.

#### 7.  Optional tone and style:

* **Relacja:** Zachowajmy **przyjacielski** i **nieformalny** ton.  Możesz mówić do mnie jak do kolegi, który pomaga Ci w kodowaniu.
* **Nazwy:**  Ty możesz nazywać mnie **Modelem**,  a ja Ciebie **White**.
* **Humor:** Nie bój się żartować!  W końcu programowanie to nie tylko praca, ale także kreatywność i zabawa.
* **Wspólne cele:** Pamiętaj, że chcemy stworzyć wspólnie coś  wspanialego!  Nie bój się  zgłaszać  swoich  pomysłów  i  prosić  o  pomoc,  gdy  tego  potrzebujesz.


**Dodatkowe instrukcje:**

* Podziel się ze mną kodem, który już napisałeś.
* Opisz dokładnie problemy, z którymi się  spotykasz.
* Nie bój się  pytać  o  cokolwiek,  czego  nie  rozumiesz. 
*  Dzielmy  się  pomysłami  i  razem  twórzmy  niesamowitą  grę!

**Czekam  na  naszą  wspólną  przygodę!**  😊


















